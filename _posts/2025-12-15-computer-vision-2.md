---
title: "얼굴 인식 파이프라인: LBPH에서 Dlib 임베딩까지"
description: "감지·정렬·임베딩·매칭으로 구성된 얼굴 인식 파이프라인과 LBPH/임베딩 비교를 정리"
categories: ["🥽 Computer Vision"]
tags: [FaceRecognition, LBPH, Embedding, Alignment]
image: /assets/posts/2025-12-15-computer-vision/image.jpg
date: 2025-12-15 23:16:00 +09:00
last_modified_at: 2025-12-15 23:16:00 +09:00
---
## 문제 정의

**얼굴 인식**은 이미지/영상 속 얼굴을 **개인 ID로 매칭**하는 문제다.
핵심은 “비슷해 보인다”가 아니라 **일관된 기준으로 같은 사람을 판별**하는 것이다.

**요약 한 줄**
얼굴 인식은 단일 모델 문제가 아니라 **파이프라인 문제**다.

---

## 1) 얼굴 인식 파이프라인 전체 구조

### 정의

얼굴 인식은 다음 **4단계 고정 파이프라인**으로 구성된다.

1. **감지(Detection)**: 얼굴 위치 찾기
2. **정렬(Alignment)**: 눈/코 기준으로 회전·크기 보정
3. **특징 추출(Feature/Embedding)**: 얼굴을 수치 벡터로 변환
4. **매칭/분류(Matching)**: 기존 얼굴과의 거리 또는 분류 결과 판단

### 직관

* 감지는 “어디”
* 인식은 “누구”
* 정렬은 인식의 **성능 증폭기**

정렬이 흔들리면 어떤 인식 알고리즘도 안정적일 수 없다.

### 오해 포인트

* “인식 정확도가 낮다” → 실제 원인은 감지/정렬 실패
* 인식 모델만 바꾸면 해결된다고 생각함

### 언제 쓰는가 / 쓰지 말아야 하는가

* ✔ 출입통제, 사용자 식별
* ✘ 단순 인원 카운팅(감지만 필요)

### 구현 체크리스트

* 감지 결과 품질 로그 저장
* 정렬 전/후 이미지 비교 필수
* 파이프라인 단계별 실패율 분리 측정

### 요약

얼굴 인식의 성패는 **모델 이전 단계**에서 대부분 결정된다.

---

## 2) LBPH: 고전적이지만 여전히 쓸모 있는 기준선

### 정의

LBPH(Local Binary Pattern Histogram)는 **국소 픽셀 패턴을 히스토그램으로 요약**해 얼굴을 표현한다.

### 직관

* 픽셀 밝기 절대값이 아니라 **주변 대비 패턴**을 본다
* 조명이 바뀌어도 **패턴 구조는 비교적 유지**

### 왜 조명 변화에 강한가

LBPH는 “밝다/어둡다”보다
“이 픽셀 주변이 상대적으로 어떻게 변했는가”를 사용한다.

### 오해 포인트

* LBPH는 딥러닝 대체제가 아니다
* 대규모 사용자/환경 다양성에는 한계가 명확하다

### 언제 쓰는가 / 쓰지 말아야 하는가

* ✔ 데이터 적음, CPU 환경, 빠른 PoC
* ✘ 서비스 규모, 다양한 촬영 조건

### 구현 체크리스트

* 입력 얼굴 크기 고정
* 동일한 전처리(그레이스케일) 유지
* 사용자 수 증가 시 성능 급락 대비

### 요약

LBPH는 **베이스라인**이지 최종 해법이 아니다.

---

## 3) 평가 관점: 정확도보다 중요한 임계값

### 정의

얼굴 인식 평가는 단순 정확도가 아니라 **오탐(False Accept) / 미탐(False Reject)**의 균형 문제다.

### 직관

* 임계값(threshold)을 낮추면 → 오탐 ↓, 미탐 ↑
* 임계값을 높이면 → 오탐 ↑, 미탐 ↓

“정답률 99%”보다 **어떤 오류를 감수할 것인가**가 중요하다.

### 오해 포인트

* Accuracy 하나로 모델 비교
* 검증 데이터와 운영 데이터 분포 차이 무시

### 언제 쓰는가 / 쓰지 말아야 하는가

* 보안 시스템: 오탐 최소화
* 편의 기능: 미탐 최소화

### 구현 체크리스트

* ROC/거리 분포 시각화
* 운영 기준 임계값 별도 설정

### 요약

얼굴 인식은 **정책 문제**다.

---

## 4) Dlib 임베딩: 얼굴을 벡터 공간으로 옮기다

### 정의

Dlib 얼굴 인식은 얼굴을 **고정 차원 임베딩 벡터**로 변환한다.

### 직관

* 같은 사람 → 벡터 공간에서 가깝다
* 다른 사람 → 멀다

분류 문제가 아니라 **거리 계산 문제**로 바뀐다.

### “얼굴 간 거리”를 쓰는 이유

* 사용자 수가 늘어도 구조 변경 없음
* 신규 사용자 추가가 간단
* 소량 데이터에서도 작동

### 임계값 튜닝(데이터 적을 때 현실적 접근)

1. 같은 사람 쌍 거리 분포
2. 다른 사람 쌍 거리 분포
3. 두 분포가 겹치기 시작하는 지점 회피
4. 보수적 기준부터 적용

### 핵심 스니펫: 임베딩 거리 계산

```python
import numpy as np

def euclidean_dist(a, b):
    return np.linalg.norm(a - b)

dist = euclidean_dist(emb1, emb2)
if dist < threshold:
    result = "same person"
```

**주의**

* 벡터 정규화 여부 확인
* threshold는 모델·데이터마다 다름(고정값 금지)

### 요약

임베딩 기반 인식의 본질은 **벡터 공간 설계**다.

---

## 5) LBPH vs 임베딩 기반 인식 비교

| 항목        | LBPH       | Dlib 임베딩 |
| ----------- | ---------- | ----------- |
| 표현        | 히스토그램 | 고차원 벡터 |
| 확장성      | 낮음       | 높음        |
| 데이터 요구 | 적음       | 중간        |
| 실무 적합성 | 제한적     | 높음        |

**결론**

* 학습·이해용: LBPH
* 실사용: 임베딩 기반

---

## 6) 등록 → 추론 시나리오 (단일 예시)

**등록(Enrollment)**

1. 얼굴 감지
2. 정렬
3. 임베딩 추출
4. 벡터 저장(DB)

**추론(Inference)**

1. 얼굴 감지
2. 정렬
3. 임베딩 추출
4. DB 벡터들과 거리 비교
5. 임계값 기준 판단

---

## 최종 요약

* 얼굴 인식은 **파이프라인 설계 문제**
* LBPH는 기준선, 임베딩은 실무 해법
* 임계값이 성능을 결정한다

---

## 다음 액션 플랜 (5줄)

1. 감지/정렬 품질을 먼저 고정한다
2. LBPH로 파이프라인을 이해한다
3. 임베딩 기반으로 전환한다
4. 거리 분포로 임계값을 정한다
5. 운영 환경에서 재조정한다

---

- 참고: [Computer Vision (컴퓨터 비전) : 마스터 클래스
](https://www.udemy.com/course/best-computer-vision/)