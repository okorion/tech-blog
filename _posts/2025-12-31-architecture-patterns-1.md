---
layout: post
title: "클라우드 시대 아키텍처 사고 전환"
description: "클라우드 환경에서 확장·지연·비용·조직 구조가 얽히는 상황을 아키텍처 패턴의 판단 프레임으로 정리"
categories: ["🧣 Architecture Patterns"]
tags: ["Architecture", "Cloud", "Trade-off", "Design Drivers"]
image: /assets/posts/2025-12-31-architecture-patterns/image.png
date: 2025-12-31 22:25:00 +09:00
---


## 한 문단 요약 — 클라우드에서 시스템 설계가 급격히 어려워진 이유
결론: 클라우드 환경에서는 **확장 단위가 작아지고, 실패가 일상화되며, 비용과 구조가 실시간으로 연결되기 때문에** 설계 난이도가 급상승했다.  
첫째, 인스턴스·컨테이너 단위 확장으로 **부분 실패(partial failure)**가 기본 전제가 됐다.  
둘째, 네트워크 호출이 늘어나 **지연(latency)과 꼬리 지연(tail latency)**가 성능을 좌우한다.  
셋째, 관리형 서비스 도입으로 **구조 선택이 곧 비용 구조**가 된다.  
넷째, 배포 주기가 짧아지며 **변경 가능성(evolvability)**이 핵심 품질 속성이 됐다.  
다섯째, 팀 분리·외부 의존성 증가로 **조직 구조가 아키텍처에 직접 반영**된다.

---

## 아키텍처 패턴은 “구현 기법”이 아니라 “판단 프레임”이다
결론: 아키텍처 패턴은 무엇을 만들지보다 **무엇을 포기할지 결정하기 위한 사고 도구**다.  

### 정의
아키텍처 패턴은 반복되는 시스템 수준 문제에 대해 **구조적 선택지와 트레이드오프 묶음**을 제공하는 설계 관점이다.

### 직관
클래스 다이어그램이 아니라 **시스템 지도**에 가깝다. 코드보다 “흐름·경계·실패 지점”을 먼저 고정한다.

### 작동 원리
패턴은 성능·확장성·운영 복잡도·비용 중 **우선순위를 명시적으로 치환**한다. 선택 순간에 얻는 것과 잃는 것이 함께 고정된다.

### 트레이드오프
- 장점: 빠른 의사결정, 재사용 가능한 판단 기준
- 비용: 과도한 일반화, 맥락 없는 도입 위험

### 체크리스트
- 이 패턴이 **해결하려는 문제**는 무엇인가?
- 대신 **악화되는 지표**는 무엇인가?
- 운영 복잡도는 누가 감당하는가?

---

## 전통적 OOP 패턴 vs 아키텍처 패턴
결론: OOP 패턴은 **코드 내부 품질**, 아키텍처 패턴은 **시스템 전체의 생존성**을 다룬다.

| 구분        | 전통적 OOP 패턴 | 아키텍처 패턴  |
| ----------- | --------------- | -------------- |
| 적용 범위   | 클래스/모듈     | 서비스/시스템  |
| 주요 관심사 | 결합도·응집도   | 확장·장애·비용 |
| 실패 영향   | 로컬 버그       | 전사 장애      |
| 변경 비용   | 상대적으로 낮음 | 매우 큼        |
| 결정 시점   | 구현 단계       | 설계 초반      |

---

## 아키텍처 드라이버: 설계를 시작하는 질문 6개
결론: 설계는 솔루션이 아니라 **질문 목록을 고정하는 작업**이다.

1. **Scalability**: 트래픽 증가 시 무엇을 수평 확장할 것인가?
2. **Availability**: 일부가 죽어도 서비스는 살아야 하는가?
3. **Reliability**: 실패를 감지·복구하는 책임은 어디에 두는가?
4. **Latency/Response**: 평균이 아닌 최악 응답 시간을 허용하는가?
5. **Cost**: 사용량 변화가 비용에 즉시 반영되어도 되는가?
6. **Evolvability**: 6개월 뒤 구조 변경을 감당할 수 있는가?

이 질문에 답하지 않은 패턴 선택은 **유행 추종**에 가깝다.

---

## 패턴은 정답이 아니라 트레이드오프 도구다 — 실패 사례
결론: 패턴 자체보다 **맥락 없는 도입**이 실패의 원인이다.

### 실패 사례 1 — 유행으로 마이크로서비스 도입
문제: 팀·트래픽 규모는 작은데 독립 배포를 이유로 MSA 채택  
결과: 네트워크 호출 증가, 관측성 부재, 운영 폭발  
교훈: **조직·운영 역량이 아키텍처의 선행 조건**이다.

### 실패 사례 2 — 성능만 보고 캐시·비동기 도입
문제: 응답 속도 개선만 목표로 캐시/비동기 추가  
결과: 데이터 일관성 붕괴, 장애 시 원인 추적 불가  
교훈: **성능 최적화는 일관성·운영 복잡도와 교환**된다.

---

## 흔한 오해와 교정
결론: 아키텍처 실패는 대부분 **개념 오해**에서 시작된다.

1. “패턴을 쓰면 잘 설계된 것이다” → **패턴은 선택이지 보증이 아니다**
2. “확장성=트래픽 처리량” → **지연·장애 격리가 더 중요할 수 있다**
3. “나중에 고치면 된다” → **아키텍처 변경은 가장 비싼 작업이다**

---

## 재학습 체크리스트
1. 해결하려는 문제가 명확한가?
2. 포기하는 품질 속성은 무엇인가?
3. 실패 시 시스템은 어떻게 행동하는가?
4. 운영·관측 책임은 어디에 있는가?
5. 비용 구조를 설명할 수 있는가?
6. 조직 구조와 충돌하지 않는가?
7. 데이터 일관성 전략이 있는가?
8. 타임아웃·폴백이 설계에 포함됐는가?
9. 배포 시 위험을 줄이는 장치가 있는가?
10. 1년 뒤에도 유지 가능한가?

---

## 다음 글(2편)에서 보게 될 것
결론: 다음 편에서는 **“확장해야 할 때 무엇을 나눌지”**를 다룬다.  
트래픽 문제를 처리량·지연·팬아웃으로 분해하고,  
확장성 패턴을 **암기가 아닌 선택 문제**로 전환한다.

---

- 참고: [  Cloud Computing 소프트웨어 아키텍처 패턴 완성하기
](https://www.udemy.com/course/cloud-computing-software-architecture-patterns-korean/)
