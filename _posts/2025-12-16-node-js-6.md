---
title: "Node.js DB 선택 가이드: SQL·Sequelize·MongoDB"
description: "데이터 구조와 트랜잭션 요구에 따라 SQL, ORM, MongoDB를 선택하는 기준을 정리"
categories: ["🟢 Node.js & Backend"]
tags: ["SQL", "Sequelize", "MongoDB", "ORM"]
image: /assets/posts/2025-12-16-node-js/image.png
date: 2025-12-16 12:40:00 +09:00
last_modified_at: 2025-12-16 12:40:00 +09:00
---

## 결론 요약

* **DB 선택은 기술 취향 문제가 아니라 데이터 구조·변경 빈도·트랜잭션 요구의 함수다.**
* SQL은 **관계·정합성·트랜잭션**이 핵심일 때 강하다.
* Sequelize(ORM)는 **생산성을 얻는 대신 쿼리 통제력과 성능 가시성을 비용으로 지불**한다.
* MongoDB/Mongoose는 **문서 단위 응집**이 맞을 때 강하지만, 관계가 많아지면 설계 난도가 급상승한다.
* 올바른 선택은 “무엇을 만들지”를 **조건문**으로 명시할 수 있을 때 가능하다.

---

# Node.js에서 DB를 다루는 3가지 방식 비교

### SQL · Sequelize(ORM) · MongoDB/Mongoose

---

## 1️⃣ 정의: 무엇을 비교하는가

이 글은 “어느 DB가 더 좋다”를 말하지 않는다.
**Node.js 프로젝트에서 어떤 조건일 때 무엇을 선택해야 하는지**를 명확히 한다.

비교 대상:

* **SQL (MySQL/PostgreSQL + Raw Query)**
* **Sequelize (ORM on SQL)**
* **MongoDB + Mongoose (ODM)**

---

## 2️⃣ 왜 필요한가: DB 선택이 늦을수록 비용은 커진다

초기에는 모든 방식이 “돌아간다”.
문제는 다음 시점에 발생한다.

* 관계가 늘어날 때
* 트랜잭션이 필요해질 때
* 조회 성능이 병목이 될 때
* 데이터 모델이 자주 바뀔 때

이때 DB 선택이 잘못되면 **리팩토링이 아니라 재작성**이 된다.

---

## 3️⃣ 핵심 비교표 ①: SQL vs NoSQL (개념 축)

| 축            | SQL                 | NoSQL(MongoDB)    |
| ------------- | ------------------- | ----------------- |
| 데이터 모델링 | 스키마 고정, 정규화 | 유연, 비정규화    |
| 쿼리          | JOIN 중심           | 문서 단위 조회    |
| 트랜잭션      | 기본 제공, 강력     | 제한적(문서 단위) |
| 확장          | 수직 확장 유리      | 수평 확장 유리    |
| 변경 비용     | 스키마 변경 비용 큼 | 구조 변경 용이    |
| 정합성        | 강함                | 설계에 의존       |

**해석**

* **관계와 일관성**이 중요하면 SQL
* **문서 응집과 유연성**이 중요하면 Mongo

---

## 4️⃣ Sequelize(ORM): 이점과 비용을 동시에 본다

### ORM이 주는 이점

* 모델 중심 개발
* CRUD 생산성 향상
* 관계 정의 자동화
* 마이그레이션 도구 제공

```js
Product.findByPk(id);
```

### ORM의 숨은 비용

| 항목         | 문제                        |
| ------------ | --------------------------- |
| 쿼리 가시성  | 실제 실행 SQL이 보이지 않음 |
| 성능         | 불필요한 JOIN/N+1 발생      |
| 복잡 쿼리    | ORM 문법이 SQL보다 난해     |
| 마이그레이션 | 대규모 변경 시 관리 비용    |

> **결론**
> ORM은 “SQL을 몰라도 되는 도구”가 아니라
> **SQL을 이해한 상태에서 생산성을 올리는 도구**다.

---

## 5️⃣ Mongoose: 문서 모델 사고방식과 함정

### 문서 모델의 핵심 질문

> “이 데이터는 **함께 조회되는가?**”

* 그렇다면 **임베딩(embedding)**
* 아니라면 **참조(reference)**

### toy 예시

```js
Order {
  userId,
  items: [{ productId, price }]
}
```

### 함정

* 임베딩 남용 → 문서 크기 폭증
* 참조 남용 → SQL JOIN 같은 수동 조회 로직 증가
* 트랜잭션 부재 → 다문서 일관성 깨짐

**Mongo는 자유도가 높은 만큼, 설계 책임도 크다.**

---

## 6️⃣ 관계 처리 방식 비교 (1:N, N:M)

### 1:N 관계 (사용자-주문)

| 방식      | 구현                |
| --------- | ------------------- |
| SQL       | foreign key + JOIN  |
| Sequelize | hasMany / belongsTo |
| Mongo     | 배열 임베딩 or 참조 |

### N:M 관계 (상품-주문)

| 방식      | 구현                     |
| --------- | ------------------------ |
| SQL       | 중간 테이블              |
| Sequelize | through 옵션             |
| Mongo     | 중간 컬렉션 or 중복 저장 |

**관계가 많아질수록 SQL의 명확성이 이점이 된다.**

---

## 7️⃣ 실무 선택 기준 표 ② (조건문 사고)

| 조건               | 유리한 선택    |
| ------------------ | -------------- |
| 데이터 관계가 복잡 | SQL            |
| 강한 트랜잭션 필요 | SQL            |
| 빠른 CRUD 개발     | Sequelize      |
| 쿼리 튜닝 중요     | Raw SQL        |
| 문서 단위 조회     | MongoDB        |
| 스키마 변경 잦음   | MongoDB        |
| 팀 SQL 숙련도 낮음 | ORM(초기 한정) |

---

## 8️⃣ 실무 결론: 조건문으로 말해보면

* **만약** 주문/결제/재고처럼 **정합성과 관계가 핵심**이면 → **SQL**
* **만약** CRUD 위주 서비스 + 빠른 개발이 필요하면 → **Sequelize**
* **만약** 로그/피드/콘텐츠처럼 **문서 응집이 자연**이면 → **MongoDB**
* **만약** ORM을 쓰더라도 성능 병목이 보이면 → **Raw SQL 병행**

DB 선택은 “하나만 고르는 문제”가 아니라
**어디까지 추상화할지 정하는 문제**다.

---

## 선택 체크리스트 (질문 10개)

* [ ] 데이터 간 관계가 몇 단계까지 필요한가?
* [ ] 트랜잭션이 비즈니스에 필수인가?
* [ ] 조회 패턴은 문서 단위인가, 조합형인가?
* [ ] 스키마 변경 빈도는 높은가?
* [ ] 팀의 SQL 이해도는 어느 수준인가?
* [ ] 성능 병목을 직접 튜닝할 가능성은?
* [ ] 마이그레이션 관리 역량이 있는가?
* [ ] 데이터 정합성 책임을 어디까지 질 수 있는가?
* [ ] 테스트 데이터 생성이 쉬워야 하는가?
* [ ] 6개월 뒤에도 이 선택을 유지할 수 있는가?

---

- 참고: [  NodeJS 완벽 가이드 : MVC, REST APIs, GraphQL, Deno
](https://www.udemy.com/course/nodejs-mvc-rest-apis-graphql-deno/)
